<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-12-08 Mon 15:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advent of Code 2025 - Day 6: Trash Compactor</title>
<meta name="author" content="Leo Laporte" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'JavaScript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Advent of Code 2025 - Day 6: Trash Compactor</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org60b4e1d">1. Day 6: Trash Compactor</a>
<ul>
<li><a href="#org0a78e68">1.1. Prologue - Setup</a></li>
<li><a href="#org52cf076">1.2. Part One</a>
<ul>
<li><a href="#org49ba835">1.2.1. Example Data</a></li>
<li><a href="#orgb410358">1.2.2. Parser</a></li>
</ul>
</li>
<li><a href="#orge87b863">1.3. Test Parse</a>
<ul>
<li><a href="#org358ff5b">1.3.1. Solution</a></li>
</ul>
</li>
<li><a href="#orgfabf9dd">1.4. Part Two</a>
<ul>
<li><a href="#orgd16ce68">1.4.1. Cephalopod Parser</a></li>
<li><a href="#orgefcedf6">1.4.2. Solution</a></li>
</ul>
</li>
<li><a href="#org1edf5c6">1.5. Solutions</a></li>
<li><a href="#orgdaaeca4">1.6. Performance</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org60b4e1d" class="outline-2">
<h2 id="org60b4e1d"><span class="section-number-2">1.</span> Day 6: Trash Compactor</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0a78e68" class="outline-3">
<h3 id="org0a78e68"><span class="section-number-3">1.1.</span> Prologue - Setup</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Standard setup for AOC solutions.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>;;;; Day06.lisp
;;;; 2025 AOC Day 6 solution
;;;; Common Lisp solutions by Leo Laporte (with lots of help)
;;;; Started: 06 Dec 2025 at 11:15
;;;; Finished:

;; ----------------------------------------------------------------------------
;; Prologue code for setup - same every day
;; ----------------------------------------------------------------------------

(defpackage :aoc.2025.day06
            (:use :cl :alexandria :iterate)      ; no prefix for these libraries
            (:local-nicknames                    ; short prefixes for these
             (:re :cl-ppcre)                     ; regex
             (:5a :fiveam)                       ; test framework
             (:sr :serapeum)                     ; CL extensions
             (:tr :trivia)))                     ; pattern matching

(in-package :aoc.2025.day06)

(setf 5a:*run-test-when-defined* t)  ; test as we go
(setf 5a:*verbose-failures* t)       ; show failing expression
(sr:toggle-pretty-print-hash-table)  ; automatic pretty print for hashes
(declaim (optimize (debug 3)))       ; max debugging info
;; (declaim (optimize (speed 3))     ; max speed if needed

(defparameter *data-file* "~/cl/AOC/2025/Day06/input.txt"
  "Downloaded from the AoC problem set")
</code></pre>
</div>
</div>
</div>
<div id="outline-container-org52cf076" class="outline-3">
<h3 id="org52cf076"><span class="section-number-3">1.2.</span> Part One</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Hmmm. Seems easy. Too easy. I&rsquo;ve got a bad feeling about this.
</p>

<p>
I&rsquo;ll <code>PARSE-INPUT</code> into two values, an array of lists, each list will contain
all the integers from the columns, and then a list of operand strings. The
problem is practically done by then. I just apply each operand to its
respective column and sum the results. The list will be very long with the
provided data but I don&rsquo;t think 1000 digits lists are particularly
problematic. Let&rsquo;s see.
</p>
</div>
<div id="outline-container-org49ba835" class="outline-4">
<h4 id="org49ba835"><span class="section-number-4">1.2.1.</span> Example Data</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-lisp"><code>(defparameter *example* (list "123 328  51 64 "
                              " 45 64  387 23 "
                              "  6 98  215 314"
                              "*   +   *   +  "))
</code></pre>
</div>
</div>
</div>
<div id="outline-container-orgb410358" class="outline-4">
<h4 id="orgb410358"><span class="section-number-4">1.2.2.</span> Parser</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-lisp"><code>(sr:-&gt; parse-input (list) (values array list))
(defun parse-input (input)
  "given a list of strings, return two values, an array of integers by column
and a list of strings representing operators"
  (let* ((rows (length input))
         (cols (length (sr:words (first input)))) ; actual numbers not spaces
         ;; an array of lists - each list contains all the integers from a column
         (digits (make-array cols :element-type 'list :initial-element nil)))

    (iter (for row below (1- rows))
      (for row-of-nums = (sr:words (nth row input))) ; chop it up first
      (iter (for col below cols)
        (setf (aref digits col)
              (push (parse-integer (nth col row-of-nums)) ; the number
                    (aref digits col)))))       ; that column's list

    ;; return array of lists of integers by column and list of operators
    (values digits (sr:tokens (lastcar input)))))
</code></pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge87b863" class="outline-3">
<h3 id="orge87b863"><span class="section-number-3">1.3.</span> Test Parse</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Let&rsquo;s see how the parser works with the example&hellip;
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb22bbcd"><code>(multiple-value-bind (digits operators) (parse-input *example*)
  (format t "Digits: ~S~%Operators: ~S~%" digits operators))
</code></pre>
</div>

<pre class="example">
Digits: #((6 45 123) (98 64 328) (215 387 51) (314 23 64))
Operators: ("*" "+" "*" "+")
</pre>
</div>
<div id="outline-container-org358ff5b" class="outline-4">
<h4 id="org358ff5b"><span class="section-number-4">1.3.1.</span> Solution</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<pre class="src src-lisp"><code>(sr:-&gt; day06-1 (list) number)
(defun day06-1 (input)
  "given a list of strings of digits and a final string of operators, produce
the sum of the results of using each operator on the column above - most of the
work is done in the parsing"
  (multiple-value-bind (digits operators) (parse-input input)

    ;; now go through each column
    (iter (for col below (length digits))
      (summing
        ;; apply the apropriate operand
        (ecase (char (nth col operators) 0)
          (#\+ (apply #'+ (aref digits col)))
          (#\* (apply #'* (aref digits col))))))))
</code></pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org958e9df"><code>(5a:test day06-1-test
  (5a:is (= 4277556 (day06-1 *example*))))
</code></pre>
</div>

<pre class="example">

Running test DAY06-1-TEST .
 Did 1 check.
    Pass: 1 (100%)
    Skip: 0 ( 0%)
    Fail: 0 ( 0%)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfabf9dd" class="outline-3">
<h3 id="orgfabf9dd"><span class="section-number-3">1.4.</span> Part Two</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Frickin&rsquo; cephalpods. They&rsquo;re as bad as the lanternfish. So it turns out that the
columns are digit by digit. And spaces are significant. This is going to require
a completely different parser. I think the final function can remain mostly the
same as long as the parsing is done correctly.
</p>

<p>
In fact, I can pretty much use the same parser with slight
modifications. Instead of using <code>WORDS</code> to extract the digits I&rsquo;ll step through
the string a column at a time, replacing spaces with zeroes and putting in the
single digits.
</p>

<p>
This is simple. Right? Right? Well not exactly. The integers to process are
combinations of all the digits in the column. So&hellip;
</p>

<pre class="example" id="org6cc09da">
64
23
314
+
</pre>

<p>
ends up being: 623 + 431 + 4. So I will have to chunk up the columns and then
index into them. A bit more complicated.
</p>

<p>
The real question is how can I determine when to begin a new column? Is the
width consistent? Alas no. Examining the input file shows that operands are
usually separated by four columns but not always (unlike the example - tricky!)
</p>

<p>
Is a new column always begun by an operator? Can I use them as an anchor? First,
a test to see if the operators do really match the start of the columns&hellip;
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org539d7c6"><code>(defun opstarts (input)
  (let* ((rows (1- (length input)))
         (op-string (nth rows input))
         (column-starts '()))

    ;; use op-string to determine column start and end
    (iter (for i below (length op-string))
      (when (not (char= #\space (char op-string i)))
        (push i column-starts)))        ; push column start

    (reverse column-starts)))

;; print the operator start list for *example*
(format t "Ops starts for *example*: ~a~%~%" (opstarts *example*))

;; compare the input to the operators (well just the first 70 characters)
(format t "First 70 chars of input: ~%~a~%~a~%~a~%~a~%~a~%"
        (subseq (first (uiop:read-file-lines *data-file*)) 0 70)
        (subseq (second (uiop:read-file-lines *data-file*)) 0 70)
        (subseq (third (uiop:read-file-lines *data-file*)) 0 70)        (subseq (fourth (uiop:read-file-lines *data-file*)) 0 70)
        (subseq (nth 4 (uiop:read-file-lines *data-file*)) 0 70))
</code></pre>
</div>

<pre class="example">
Ops starts for *example*: (0 4 8 12)

First 70 chars of input: 
886  63  27 258 98 318 99 975  7 6393 947 87 23 765 35      1 6415 4  
652  49  14  97 72 335 28 269 23 1648 698 46 68 814 3193   89  421 13 
65  143  36   8 42 429 55 327 44  775 558 76 85 171 6136 9139   23 97 
8   686 695   9 4  689 2  373 96  131 7   41 96 28  7328 8919   66 68 
*   +   +   *   +  +   *  +   *  +    +   *  *  +   +    +    +    *  
</pre>

<p>
Yep that seems to work for the example and at least for the first 70 of 1000
characters in the input data. I think it&rsquo;s worth going forward with that assumption, so I think the easiest way to do this is to create a new parser, CEPHLAPOD-PARSE, that creates a 2D array of digits grouped by column, instead of WORDS, and I might as well keep the list of operators in the array.
</p>
</div>
<div id="outline-container-orgd16ce68" class="outline-4">
<h4 id="orgd16ce68"><span class="section-number-4">1.4.1.</span> Cephalopod Parser</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-lisp" id="org923e257"><code>(sr:-&gt; cephalapod-parse (list) array)
(defun cephalapod-parse (input)
  "given a list of strings, return a 2D array with number strings grouped by column"
  (let ((rows (length input))       ; number of lines will be rows in arr
        (column-starts '())             ; indices into line for each column
        (operators (lastcar input)))    ; the operators are the last line

    ;; use the operators to determine column starts
    (iter (for i below (length operators))
      (when (not (char= #\space (char operators i))) ; it's an operand
        (push i column-starts))) ; save the location of the operand
    (setf column-starts (reverse column-starts))

    ;; now fill the 2d array GRID with numbers by column groups
    (let ((grid (make-array (list rows (length column-starts))
                            :element-type 'list
                            :initial-element nil)))
      (iter (for line in input)
        (for row :from 0)
        (iter (for (start . rest) on column-starts)
          (for group :from 0)
          (setf (aref grid row group)
                (push (subseq line start (first rest))
                      (aref grid row group)))))
      grid)))
</code></pre>
</div>

<p>
Let&rsquo;s see what that produces&hellip; BTW I&rsquo;ve changed my source template in the Emacs ORG-MODE.EL configuration to provide an automatic name for every source block using the current time. Just to keep things straight.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgae26253"><code>(format t "Example: ~%~a" (cephalapod-parse *example*))
</code></pre>
</div>

<pre class="example">
Example: 
#2A(((123 ) (328 ) ( 51 ) (64 ))
    (( 45 ) (64  ) (387 ) (23 ))
    ((  6 ) (98  ) (215 ) (314))
    ((*   ) (+   ) (*   ) (+  )))
</pre>

<p>
I see I am capturing the space at the end of each column except the last. I can deal witth that later. Let&rsquo;s see if I can get the columns.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0cb406f"><code>
(let ((arr (cephalapod-parse *example*)))
(iter (for col below (array-dimension arr 1))
    (collect
       (iter (for row below (array-dimension arr 0))
          (collect (car (aref arr row col)))))))

</code></pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">123</td>
<td class="org-right">45</td>
<td class="org-right">6</td>
<td class="org-left">*</td>
</tr>

<tr>
<td class="org-right">328</td>
<td class="org-right">64</td>
<td class="org-right">98</td>
<td class="org-left">+</td>
</tr>

<tr>
<td class="org-right">51</td>
<td class="org-right">387</td>
<td class="org-right">215</td>
<td class="org-left">*</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-right">23</td>
<td class="org-right">314</td>
<td class="org-left">+</td>
</tr>
</tbody>
</table>

<p>
OK good. So each row contains the proper strings followed by the operator. I need to take those strings and process them character by character.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2fd1729"><code>
(let ((arr (cephalapod-parse *example*)))
       (iter (for col below (array-dimension arr 1))
          (print (car (aref arr col 0)))))

</code></pre>
</div>

<pre class="example">

"123 " 
" 45 " 
"  6 " 
"*   " 
</pre>

<p>
Yeah they line up nicely. I&rsquo;m looking to turn that into (* 1 24 356) - so I&rsquo;d  take char 0 of the first three, turn that into 1. char 1 of lines 0-2 turns into 24, char 2 of lines 0-2 is 356 and then char 0 of line 4 is *, the operand. I&rsquo;m looking to write a function, PROCESS-COL, that does that for a single row. I&rsquo;ll start with the tests.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6691571"><code>(sr:-&gt; process-cols (list) number)
(defun process-cols (row)
  "Given a list of strings representing a row, with each number aligned with
spaces, and the last item representing an operator, return the result of
applying the operator to the digits formed by going from top to bottom column by
column."
  (let* ((operator-string (lastcar row))    ; last element of row is the op
         (digit-list (butlast row))         ; the list of number strings
         (cols (length (first digit-list))) ; length of each number string
         (numbers         ; list of the operands created by concatenating by col
           (iter (for c below cols)
             ;; collect the numbers by going down the columns
             (for digits =
                  (iter (for str in digit-list)
                    (collect (subseq str c (1+ c)) into pieces)
                    (finally (return (apply #'concatenate 'string pieces)))))
             (collect (parse-integer digits :junk-allowed t)))))

    (setf numbers (remove nil numbers)) ; the line of spaces at the end is nil
    (ecase (char operator-string 0)
      (#\+ (apply #'+ numbers))
      (#\* (apply #'* numbers)))))


(5a:test process-cols-test
  (5a:is (= (process-cols '("123 "
                            " 45 "
                            "  6 "
                            "*   ")) (* 1 24 356)))
  (5a:is (= (process-cols '("328 "
                            "64  "
                            "98  "
                            "+   ")) (+ 369 248 8)))
  (5a:is (= (process-cols '(" 51 "
                            "387 "
                            "215 "
                            "*   ")) (* 32 581 175)))
  (5a:is (= (process-cols '("64 "
                            "23 "
                            "314"
                            "+  ")) (+ 623 431 4))))

</code></pre>
</div>

<pre class="example">

Running test PROCESS-COLS-TEST ....
 Did 4 checks.
    Pass: 4 (100%)
    Skip: 0 ( 0%)
    Fail: 0 ( 0%)
</pre>

<p>
Looking good. Now I just have to put it all together.
</p>
</div>
</div>
<div id="outline-container-orgefcedf6" class="outline-4">
<h4 id="orgefcedf6"><span class="section-number-4">1.4.2.</span> Solution</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-lisp"><code>(sr:-&gt; day06-2 (list) number)
(defun day06-2 (input)
  (let* ((grid (cephalapod-parse input)) ; make 2D array of input
         (column-list ; transpose it into a list of lists of strings
           (iter (for col below (array-dimension grid 1))
             (collect
                 (iter (for row below (array-dimension grid 0))
                   (collect (car (aref grid row col))))))))

    ;; process each number string by adding digits column by column
    (iter (for column in column-list)
      (summing (process-cols column)))))

(5a:test day06-2-test
  (5a:is (= 3263827 (day06-2 *example*))))
</code></pre>
</div>

<pre class="example">

Running test DAY06-2-TEST .
 Did 1 check.
    Pass: 1 (100%)
    Skip: 0 ( 0%)
    Fail: 0 ( 0%)
</pre>

<p>
Very nice the test passes. But I get an out-of-bounds error on the data. Ah I see the problem. When I transpose the array I&rsquo;m using row col instead of col row - that makes it out of bounds. That worked because I accidentally swapped rows and cols in the iter clauses (which only worked in the <b>example</b> because it&rsquo;s a square - the data is most definitely not square!). Swapped the iter clauses  and used the proper  (aref arr row col) and it works again. All done. And it only took two days! At least the solution to part 2 took 0 seconds!
</p>
</div>
</div>
</div>
<div id="outline-container-org1edf5c6" class="outline-3">
<h3 id="org1edf5c6"><span class="section-number-3">1.5.</span> Solutions</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<pre class="src src-lisp" id="org81971b1"><code>;; now solve the puzzle!
(time (format t "The answer to AOC 2025 Day 6 Part 1 is ~a~%"
              (day06-1 (uiop:read-file-lines *data-file*))))

 (time (format t "The answer to AOC 2025 Day 6 Part 2 is ~a~%"
 	      (day06-2 (uiop:read-file-lines *data-file*))))
</code></pre>
</div>

<pre class="example">
The answer to AOC 2025 Day 6 Part 1 is 5873191732773
The answer to AOC 2025 Day 6 Part 2 is 11386445308378
</pre>
</div>
</div>
<div id="outline-container-orgdaaeca4" class="outline-3">
<h3 id="orgdaaeca4"><span class="section-number-3">1.6.</span> Performance</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Timings with SBCL on a 2023 MacBook Pro M3 Max with 64GB RAM and Tahoe 26.1
</p>

<p>
Evaluation took:
  0.002 seconds of real time
  0.002017 seconds of total run time (0.001854 user, 0.000163 system)
  100.00% CPU
  641,616 bytes consed
</p>

<p>
Evaluation took:
  0.000 seconds of real time
  0.000915 seconds of total run time (0.000859 user, 0.000056 system)
  100.00% CPU
  1,505,808 bytes consed
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: Started Sat Dec 6 2025 11:15, Finished: Mon Dec  8 15:15:20 2025</p>
<p class="author">Author: Leo Laporte</p>
<p class="date">Created: 2025-12-08 Mon 15:33</p>
</div>
</body>
</html>
