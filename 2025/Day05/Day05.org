#+title: AOC 2025 Day 5: Cafeteria
#+author: Leo Laporte
#+date: Started: 04 Dec 2025 at 21:00, Finished: 05 Dec 2025 at 09:45
#+property: header-args:lisp :session *sly-session* :results output :exports both :eval yes
#+auto_tangle: t

* Problem Description

Day 5 of Advent of Code 2025: Cafeteria

*Part One:* How many ingredient IDs are considered to be fresh according to the fresh ingredient ID ranges?

Part Two: How many total ingredients could be fresh (as described by the ranges).

* Approach

** Part 1
Choosing the right data format is half the job. Parse the input into ranges and ingredients, then count how many ingredients fall within the ranges.

The only hitch is that because an ingredient can appear in multiple ranges, we have to stop counting matches as soon as the first match shows up in order not to count multiple matches.

** Part 2
The initial approach of expanding ranges was too slow. Instead, we need to figure out where ranges overlap and merge them, then calculate the total length of the remaining ranges.

I went to bed with part 2 unfinished but I had a dream in which I explained the solution to someone! The dream wasn't fully accurate but it was very close.

The trick is to merge all overlapping ranges then sum the lengths of each range. The solution uses:
- =overlap?= to test whether ranges overlap (including ranges fully within each other)
- =merge-ranges= which takes overlapping ranges and reduces them to a single range
- Both functions require ranges that are sorted - both by start and end

The overlapping range issue was discovered when the test passed but the final answer was too low. Paul Holder provided a perverse example which demonstrated the issue with ranges within ranges as well as the need to sort by both start and finish.

* Setup
:PROPERTIES:
:header-args:lisp: :tangle Day05.lisp :comments link
:END:

** Package Definition

#+begin_src lisp
;;;; Day05.lisp
;;;; 2025 AOC Day 5 solution
;;;; Common Lisp solutions by Leo Laporte (with lots of help)
;;;; Started: 04 Dec 2025 at 21:00
;;;; Finished: 05 Dec 2025 at 09:45

;; ----------------------------------------------------------------------------
;; Prologue code for setup - same every day
;; ----------------------------------------------------------------------------

(defpackage :aoc.2025.day05
  (:use :cl :alexandria :iterate)      ; no prefix for these libraries
  (:local-nicknames                    ; short prefixes for these
   (:re :cl-ppcre)                     ; regex
   (:5a :fiveam)                       ; test framework
   (:sr :serapeum)                     ; CL extensions
   (:tr :trivia)))                     ; pattern matching

(in-package :aoc.2025.day05)

(setf 5a:*run-test-when-defined* t)  ; test as we go
(setf 5a:*verbose-failures* t)       ; show failing expression
(sr:toggle-pretty-print-hash-table)  ; automatic pretty print for hashes
(declaim (optimize (debug 3)))       ; max debugging info
;; (declaim (optimize (speed 3))     ; max speed if needed

(defparameter *data-file* "~/cl/AOC/2025/Day05/input.txt"
  "Downloaded from the AoC problem set")
#+end_src

** Example Data

#+begin_src lisp
(defparameter *example* (list "3-5"
                              "10-14"
                              "16-20"
                              "12-18"
                              ""
                              "1"
                              "5"
                              "8"
                              "11"
                              "17"
                              "32"))
#+end_src

* Part 1: Count Fresh Ingredients

** Parsing Functions

#+begin_src lisp
(sr:-> parse-input (list) (values list list))
(defun parse-input (input)
  "given a list of strings representing numeric ranges represented as 1-2 and
ingredients represented as a number string return a list of ranges and
ingredients"
  (let ((ranges nil)
        (ingredients nil))

    (iter (for line in input)
      (cond ((re:scan-to-strings "\\d+-\\d+" line)
             (push (mapcar #'parse-integer (sr:words line)) ranges))

            ((re:scan-to-strings "\\d+" line)
             (push (parse-integer line) ingredients))))

    (values ranges ingredients)))

(sr:-> in-range? (number list) boolean)
(defun in-range? (num range)
  "returns t if NUM is in the range, inclusive"
  (<= (first range) num (second range)))
#+end_src

** Tests for Helper Functions

#+begin_src lisp
(5a:test in-range?-test
  (5a:is-true (in-range? 10 '(10 15)))
  (5a:is-true (in-range? 14 '(10 15)))
  (5a:is-true (in-range? 15 '(10 15)))
  (5a:is-false (in-range? 9 '(10 15)))
  (5a:is-false (in-range? 16 '(10 15))))
#+end_src

** Solution Function

#+begin_src lisp
(sr:-> day05-1 (list) number)
(defun day05-1 (input)
  "given a list of ingredients and a list of ranges of fresh ingredients return
the total number of fresh ingredients."
  (let ((fresh 0))
    (multiple-value-bind (ranges ingredients) (parse-input input)
      (iter (for i in ingredients)
        (iter (for r in ranges)
          (when (in-range? i r)
            (incf fresh)
            (finish)))))                ; end inside loop and continue
    fresh))
#+end_src

** Tests

#+begin_src lisp
(5a:test day05-1-test
  (5a:is (= 3 (day05-1 *example*))))
#+end_src

* Part 2: Merge Overlapping Ranges

** Additional Example Data

#+begin_src lisp
(defparameter *example2* (list "1-100"
                               "1-10"
                               "1-15"
                               "2-8"
                               "2-14"
                               "2-20")
  "a perverse example from Paul Holder with ranges WITHIN ranges and requiring
a secondary sort (first ends, then starts)")
#+end_src

** Range Merging Functions

#+begin_src lisp
(sr:-> overlap? (list list) boolean)
(defun overlap? (r1 r2)
  "returns t if two number pairs overlap, assumes pairs are sorted
 ascending by their second then first digits"
  (or
   ;; the first range fully engulfs the second
   (and (<= (first r1) (first r2)) (<= (second r2) (second r1)))
   ;; the end of the first is lower than the start of the second
   (>= (second r1) (first r2))))

(sr:-> merge-ranges (list list) list)
(defun merge-ranges (r1 r2)
  "merges two overlapping number pairs into a single list - assumes r1 and r2
are sorted by end then start"
  (if (and (<= (first r1) (first r2)) (<= (second r2) (second r1)))
      ;; r2 is within r1
      (list (first r1) (second r1))
      ;; else r1 and r2 partially overlap
      (list (first r1) (second r2))))

(sr:-> merge-all-ranges (list list) list)
(defun merge-all-ranges (ranges merged)
  "takes a list of number pairs, RANGES, and merges the overlapping pairs,
returns MERGE, a list of all pairs reduced to non-overlapping pairs, assumes
 pairs are sorted ascending by the second then first digits"
  (cond ((null (cdr ranges))
         ;; done so push the last range and return
         (reverse (push (first ranges) merged)))

        ((overlap? (first ranges) (first (rest ranges)))
         ;; merge the overlaps then continue with the merged range and the
         ;; rest of the list
         (merge-all-ranges
          (cons (merge-ranges (first ranges) (first (rest ranges)))
                (rest (rest ranges))) merged))

        (t ;; not overlapping so save and continue with rest
         (push (first ranges) merged)
         (merge-all-ranges (rest ranges) merged))))
#+end_src

** Tests for Range Functions

#+begin_src lisp
(5a:test overlap?-test
  (5a:is-true (overlap? '(1 5) '(4 10)))
  (5a:is-true (overlap? '(1 5) '(5 10)))
  (5a:is-false (overlap? '(1 5) '(6 10)))
  (5a:is-true (overlap? '(1 5) '(2 4)))
  (5a:is-true (overlap? '(1 5) '(2 5)))
  (5a:is-true (overlap? '(1 5) '(1 5))))

(5a:test merge-ranges-test
  (5a:is (equal (merge-ranges '(1 5) '(5 10)) '(1 10)))
  (5a:is (equal (merge-ranges '(1 6) '(5 10)) '(1 10)))
  (5a:is (equal (merge-ranges '(1 5) '(2 4)) '(1 5))))

(5a:test merge-all-ranges-test
  (5a:is (equal (merge-all-ranges (list '(3 5) '(10 14) '(12 18) '(16 20)) '())
                (list '(3 5) '(10 20))))
  (5a:is (equal (merge-all-ranges (list '(3 5) '(10 14) '(12 18) '(19 20)) '())
                (list '(3 5) '(10 18) '(19 20))))
  (5a:is (equal (merge-all-ranges
                 (list '(3 5) '(10 14) '(12 18) '(19 20) '(21 22)) '())
                (list '(3 5) '(10 18) '(19 20) '(21 22))))
  (5a:is (equal (merge-all-ranges
                 (list '(3 5) '(6 14) '(12 18) '(19 20)) '())
                (list '(3 5) '(6 18) '(19 20)))))
#+end_src

** Solution Function

#+begin_src lisp
(sr:-> day05-2 (list) number)
(defun day05-2 (input)
  "given a list of strings describing a set of ranges, returns the total
 number of items in those ranges"
  (sr:~> (parse-input input)            ; get the ranges as a list of pairs
         (sort _ #'< :key #'second)     ; sort by the end of each pair
         (sort _ #'< :key #'first)      ; then by the start
         (merge-all-ranges _ '())       ; merge overlapping pairs
         (mapcar
          (lambda (x) (1+ (- (second x) (first x)))) _) ; get lengths
         (apply #'+ _)))                                ; add lengths
#+end_src

** Tests

#+begin_src lisp
(5a:test day05-2-test
  (5a:is (= 14 (day05-2 *example*)))
  (5a:is (= 100 (day05-2 *example2*))))
#+end_src

* Run Solutions

#+begin_src lisp
;; now solve the puzzle!
(time (format t "The answer to AOC 2025 Day 5 Part 1 is ~a"
              (day05-1 (uiop:read-file-lines *data-file*))))

(time (format t "The answer to AOC 2025 Day 5 Part 2 is ~a"
              (day05-2 (uiop:read-file-lines *data-file*))))
#+end_src

* Performance Results

Timings with SBCL on a 2023 MacBook Pro M3 Max with 64GB RAM and Tahoe 26.1

#+begin_example
The answer to AOC 2025 Day 5 Part 1 is 509
Evaluation took:
0.003 seconds of real time
0.003049 seconds of total run time (0.002995 user, 0.000054 system)
100.00% CPU
397,648 bytes consed

The answer to AOC 2025 Day 5 Part 2 is 336790092076620
Evaluation took:
0.001 seconds of real time
0.001579 seconds of total run time (0.001559 user, 0.000020 system)
200.00% CPU
393,136 bytes consed
#+end_example
